# RFC 200, by Nathan Wiger: Revamp tie to support extensibility

[Proposed on 7 September 2000](https://raku.org/archive/rfc/200.html),
frozen on 20 September 2000, depends on
[RFC 159: True Polymorphic Objects](https://raku.org/archive/rfc/159.html)
proposed on 25 August 2000, frozen on 16 September 2000, also by *Nathan Wiger*.

## RFC159 background

RFC159 introduces the concept of true polymorphic object.

> Objects that can morph into numbers, strings, booleans and much more on-demand.  As such, objects can be freely passed around and manipulated without having to care what they contain (or even that they're objects).

When one looks at how `42`, `"foo"`, `now` work in Raku nowadays, one can
only see that that vision has pretty much been implemented.  Because  most
of the time, one doesn't really care about the fact that `42` is really an
`Int` object, `"foo"` is really a `Str` object and that `now` represents
a new `Instant` object every time it is called.  The only thing one cares
about, is that they can be used in expressions:

    say "foo" ~ "bar";  # foobar
    say 42 + 666;       # 708
    say now - INIT now; # 0.0005243

RFC159 lists a number of method names to be used to indicate how an object
should behave under certain circumstances, with a fallback provided by the
system if the class of the object does not provide that method.  In most
cases these methods did not make it into Raku, but some of them did with
a different name:

|Name in RFC|Name in Raku|When|
|-----------|------------|----|
|STRING     | Str        |Called in a string context|
|NUMBER     | Numeric    |Called in a numeric context|
|BOOLEAN    | Bool       |Called in a boolean context|

And some of them even retained their name:

|Name in RFC|When|
|-----------|----|
|BUILD      |Called in object blessing|
|STORE      |Called in an lvalue = context|
|FETCH      |Called in an rvalue = context|
|DESTROY    |Called in object destruction|

In the end, only a limited set of *special* methods was decided on for
Raku.  All of the other methods in RFC159 have been implemented by
polymorphic operators that coerce when needed.  For instance the
proposed `PLUS` method has been implemented as an infix `+` operator
that has a "default" candidate that coerces its operands to a number.

So effectively, if you have an object of class `Foo` and you want
that to act as a number, one only needs to add a `Numeric` method
to that class.  An expression such as:

    my $foo = Foo.new;
    say $foo + 42;

is effectively running:

    say infix:<+>( $foo, 42 );

and the `infix:<+>` candidate that takes `Any` objects, does:

    return infix:<+>( $foo.Numeric, 42.Numeric );

# Conclusion

