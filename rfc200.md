# RFC 200, by Nathan Wiger: Revamp tie to support extensibility

Proposed on 7 September 2000, frozen on 20 September 2000, depends on
[RFC 159: True Polymorphic Objects](https://raku.org/archive/rfc/159.html)
proposed on 25 August 2000, frozen on 16 September 2000, also by *Nathan Wiger*
and [already blogged about earlier](https://raku-advent.blog/2020/08/17/rfc-159-by-nathan-wiger-true-polymorphic-objects/).

## What is `tie` anyway?

[RFC 200](https://raku.org/archive/rfc/200.html) was about extending the
[tie](https://perldoc.perl.org/5.32.0//functions/tie.html) functionality
as offered by Perl.

This functionality in Perl allows one to *inject* program logic into the
system's handling of scalars, arrays and hashes, among other things.  This
is done by assigning the name of a package to a data-structure such as an
array (aka *tying*).  That package is then expected to provide a number of
subroutines (e.g. `FETCH` and `STORE`) that will be called by the system
to achieve certain effects on the given data-structure.

As such, it is used by some of Perl's core modules, such as
[threads](https://perldoc.perl.org/5.32.0/threads.html), and many
modules on CPAN, such as [Tie::File](https://metacpan.org/pod/Tie::File).
The `tie` functionality of Perl still suffers from the problems mentioned
in the RFC.

## It's *all* tied

In Raku, *everything* is an object, or can be considered to be an object.
Everything the system needs to do with an object, is done through its
methods.  In that sense, you could say that *everything* in Raku is a
`tied` object.  Fortunately, Raku can recognize when certain methods
on an object are in fact the ones supplied by the system, and actually
create short-cuts at compile time (e.g. when assigning to a variable
that has a standard container: it then won't actually call a `STORE`
method, but uses an internal subroutine to achieve the desired effect).

But apart from that, Rakudo (the most advanced implementation of the
Raku Programming Language) has the capability of identifying hot code
paths *during execution* of a program, and optimize these in real time.
> *Jonathan Worthington* gave a very nice presentation about this process.  [How does deoptimization help us go faster](http://jnthn.net/papers/2017-spw-deopt.pdf) from 2017, and a [Performance Update](http://jnthn.net/papers/2019-perlcon-performance.pdf) from 2019.



# Conclusion

