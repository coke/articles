# RFC 159, by Nathan Wiger: True Polymorphic Objects

[Proposed on 25 August 2000](https://raku.org/archive/rfc/159.html),
frozen on 16 September 2000

## On polymorphism

RFC159 introduces the concept of true polymorphic object.

> Objects that can morph into numbers, strings, booleans and much more on-demand.  As such, objects can be freely passed around and manipulated without having to care what they contain (or even that they're objects).

When one looks at how `42`, `"foo"`, `now` work in Raku nowadays, one can
only see that that vision has pretty much been implemented.  Because  most
of the time, one doesn't really care about the fact that `42` is really an
`Int` object, `"foo"` is really a `Str` object and that `now` represents
a new `Instant` object every time it is called.  The only thing one cares
about, is that they can be used in expressions:

    say "foo" ~ "bar";  # foobar
    say 42 + 666;       # 708
    say now - INIT now; # 0.0005243

RFC159 lists a number of method names to be used to indicate how an object
should behave under certain circumstances, with a fallback provided by the
system if the class of the object does not provide that method.  In most
cases these methods did not make it into Raku, but some of them did with
a different name:

|Name in RFC|Name in Raku|When|
|-----------|------------|----|
|STRING     | Str        |Called in a string context|
|NUMBER     | Numeric    |Called in a numeric context|
|BOOLEAN    | Bool       |Called in a boolean context|

And some of them even retained their name:

|Name in RFC|When|
|-----------|----|
|BUILD      |Called in object blessing|
|STORE      |Called in an lvalue = context|
|FETCH      |Called in an rvalue = context|
|DESTROY    |Called in object destruction|

but with sometimes subtly different semantics from the RFC.

## Only a few made it

In the end, only a limited set of *special* methods was decided on for
Raku.  All of the other methods in RFC159 have been implemented by
polymorphic operators that coerce when needed.  For instance the
proposed `PLUS` method has been implemented as an infix `+` operator
that has a "default" candidate that coerces its operands to a number.

So effectively, if you have an object of class `Foo` and you want
that to act as a number, one only needs to add a `Numeric` method
to that class.  An expression such as:

    my $foo = Foo.new;
    say $foo + 42;

is effectively executing:

    say infix:<+>( $foo, 42 );

and the `infix:<+>` candidate that takes `Any` objects, does:

    return infix:<+>( $foo.Numeric, 42.Numeric );

And if such a class `Foo` does not provide a `Numeric` method,
then it will throw an exception in that situation.

## The DESTROY method

In Raku, object destruction is non-deterministic.  If an object is no
longer in use, it *will* **probably** get garbage collected.  The
*probable* part is because Raku does not know a global destruction
phase, unlike Perl.  So when a program is done, it just does an
`exit` (although that logic *does* honour any `END` blocks).

An object is marked "ready for removal" when it can no longer be
"reached".  It then has its `DESTROY` method called when the garbage
collection logic kicks in.  Which can be any amount of time after it
became unreachable.

If you need deterministic calling of the `DESTROY` method, you can
use a [`LEAVE`](https://docs.raku.org/syntax/LEAVE) phaser.  Of if
that doesn't allow you to scratch your itch, you can possibly use the
[`FINALIZER`](https://modules.raku.org/dist/FINALIZER:cpan:ELIZABETH)
module.

## STORE / FETCH on scalar values

Conceptually, you can think of a container in Raku as an object with
`STORE` and `FETCH` methods.  Whenever you set a value in a container,
it conceptually calls the `STORE` method.  And whenever the value
inside the container is needed, it conceptually calls the `FETCH`
method.  In pseudo-code:

    my $foo = 42;  # Scalar.new(:name<$foo>).STORE(42)

But what if you want to control access to a scalar value, similar to
Perl's `tie`?  Well, in Raku you can, with a special type of container
class called [`Proxy`](https://docs.raku.org/type/Proxy).  An example
of its usage:

    sub proxier($value? is copy) {
        return-rw Proxy.new(
            FETCH => method { $value },
            STORE => method ($new) {
                say "storing";
                $value = $new
            }
        )
    }

    my $a := proxier(42);
    say $a;    # 42
    $a = 666;  # storing
    say $a;    # 666

Subroutines return their result values de-containerized by default.
There are basically two ways of making sure the actual container is
returned: using [`return-rw`](https://docs.raku.org/syntax/return-rw)
(like in this example), or by marking the subroutine with the
[`is rw`](https://docs.raku.org/routine/is%20rw#class_Routine) trait.

# Conclusion

