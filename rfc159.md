# RFC 159, by Nathan Wiger: True Polymorphic Objects

[Proposed on 25 August 2000](https://raku.org/archive/rfc/159.html),
frozen on 16 September 2000

## On polymorphism

RFC159 introduces the concept of true polymorphic object.

> Objects that can morph into numbers, strings, booleans and much more on-demand.  As such, objects can be freely passed around and manipulated without having to care what they contain (or even that they're objects).

When one looks at how `42`, `"foo"`, `now` work in Raku nowadays, one can
only see that that vision has pretty much been implemented.  Because  most
of the time, one doesn't really care about the fact that `42` is really an
`Int` object, `"foo"` is really a `Str` object and that `now` represents
a new `Instant` object every time it is called.  The only thing one cares
about, is that they can be used in expressions:

    say "foo" ~ "bar";  # foobar
    say 42 + 666;       # 708
    say now - INIT now; # 0.0005243

RFC159 lists a number of method names to be used to indicate how an object
should behave under certain circumstances, with a fallback provided by the
system if the class of the object does not provide that method.  In most
cases these methods did not make it into Raku, but some of them did with
a different name:

|Name in RFC|Name in Raku|When|
|-----------|------------|----|
|STRING     | Str        |Called in a string context|
|NUMBER     | Numeric    |Called in a numeric context|
|BOOLEAN    | Bool       |Called in a boolean context|

And some of them even retained their name:

|Name in RFC|When|
|-----------|----|
|BUILD      |Called in object blessing|
|STORE      |Called in an lvalue = context|
|FETCH      |Called in an rvalue = context|
|DESTROY    |Called in object destruction|

but with sometimes subtly different semantics from the RFC.

## Only a few made it

In the end, only a limited set of *special* methods was decided on for
Raku.  All of the other methods in RFC159 have been implemented by
polymorphic operators that coerce when needed.  For instance the
proposed `PLUS` method has been implemented as an infix `+` operator
that has a "default" candidate that coerces its operands to a number.

So effectively, if you have an object of class `Foo` and you want
that to act as a number, one only needs to add a `Numeric` method
to that class.  An expression such as:

    my $foo = Foo.new;
    say $foo + 42;

is effectively executing:

    say infix:<+>( $foo, 42 );

and the `infix:<+>` candidate that takes `Any` objects, does:

    return infix:<+>( $foo.Numeric, 42.Numeric );

And if such a class `Foo` does not provide a `Numeric` method,
then it will throw an exception in that situation.

## The DESTROY method

In Raku, object destruction is non-deterministic.  If an object is no
longer in use, it *will* **probably** get garbage collected.  Contrary
to Perl.

# Conclusion

